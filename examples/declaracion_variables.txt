principal()
{
    ini_var
        entero ve, a, v, c, g, n;
        real vf, x, z, m, j;
        car vc;
        bool vl;
        entero pe, pe2;
        real pf, pf2;
        car pc, pc2;
        bool pl, pl2;
    fin_var

    real funcionB (car b1, bool b2)
    {
        ini_var
            real xf, x2;
        fin_var

        real funcionC (bool c1, entero c2)
        {
            ini_var
                real x1;
                entero aux;
            fin_var

            x1 = 1.3;


            si (c2>10)
                 c2 = c2 - 1;
            sino
                x1=3.1;



            devolver x1;
        }
        real funcionD (bool c1, entero c2)
        {
            ini_var
                real x1;
            fin_var

            x1 = 1.3;
            si (c2>10)
                c2 = c2 - 1;
            sino
                x1=3.1;
            devolver x1;
        }

        xf = funcionC(Verdadero, 10);
        x2 = xf*(funcionC(Falso,1)-funcionC(Verdadero,23))/10.0;
        // Parámetros invertidos -> debería dar error
        x2 = funcionC(10,Verdadero);

        mientras(x2*funcionC(Falso,2)-xf<10.0)
            x2=x2*xf;

        devolver x2;
    }


    pe=pe2;
    // pe3 no existe -> debería dar error
    pe2=pe3;
    // vl y vc no son del mismo tipo -> debería dar error
    vl=vc;
    vf = 1.3;

    devolver 0;
}
